import fs from "node:fs/promises";
import fsSync from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const repoRoot = path.resolve(path.dirname(fileURLToPath(import.meta.url)), "..");
const sectionsDir = path.join(repoRoot, "app", "home", "sections");
const sectionsIndexPath = path.join(sectionsDir, "sections.json");
const outPath = path.join(repoRoot, "app", "home", "home.sections.generated.ts");

const readJson = async (filePath) => {
  const raw = await fs.readFile(filePath, "utf8");
  return JSON.parse(raw);
};

const generate = async () => {
  const index = await readJson(sectionsIndexPath);
  if (!Array.isArray(index)) {
    throw new Error(`Expected ${sectionsIndexPath} to be an array`);
  }

  const sections = [];
  for (const entry of index) {
    if (!entry || typeof entry !== "object") continue;

    const id = String(entry.id || "").trim();
    const title = String(entry.title || "").trim();
    const file = String(entry.file || "").trim();

    if (!id || !title || !file) {
      throw new Error(`Invalid entry in sections.json: ${JSON.stringify(entry)}`);
    }

    const htmlPath = path.join(sectionsDir, file);
    const html = await fs.readFile(htmlPath, "utf8");
    sections.push({ id, title, html });
  }

  const homeContentIndex = {
    schemaVersion: 1,
    generatedAt: "generated",
    source: "app/home/sections/*.html",
    title: "Home",
    sections,
  };

  const out =
    "// This file is generated by scripts/generate-home-sections.mjs\n" +
    "// Do not edit directly. Edit app/home/sections/*.html instead.\n\n" +
    `export const homeContentIndex = ${JSON.stringify(homeContentIndex, null, 2)} as const;\n`;

  await fs.mkdir(path.dirname(outPath), { recursive: true });
  const tmpPath = `${outPath}.tmp`;
  await fs.writeFile(tmpPath, out, "utf8");
  await fs.rm(outPath, { force: true });
  await fs.rename(tmpPath, outPath);

  // eslint-disable-next-line no-console
  console.log(`[home] wrote ${path.relative(repoRoot, outPath)} (${sections.length} sections)`);
};

const args = new Set(process.argv.slice(2));
const watchMode = args.has("--watch");

const watchAndGenerate = async () => {
  await generate();

  let timer = null;
  let running = false;
  let rerun = false;

  const schedule = () => {
    if (timer) clearTimeout(timer);
    timer = setTimeout(async () => {
      if (running) {
        rerun = true;
        return;
      }

      running = true;
      do {
        rerun = false;
        try {
          await generate();
        } catch (err) {
          // eslint-disable-next-line no-console
          console.error(err);
        }
      } while (rerun);
      running = false;
    }, 120);
  };

  const watcher = fsSync.watch(
    sectionsDir,
    { recursive: true },
    (eventType, fileName) => {
      const file = String(fileName ?? "");
      const shouldRegenerate = !file || file.endsWith(".html") || file === "sections.json";
      if (!shouldRegenerate) return;

      // eslint-disable-next-line no-console
      console.log(
        file
          ? `[home] change detected (${eventType}): ${file}`
          : `[home] change detected (${eventType})`,
      );
      schedule();
    },
  );

  // eslint-disable-next-line no-console
  console.log("[home] watching app/home/sections/*.html and sections.json");

  const stop = () => {
    watcher.close();
    if (timer) clearTimeout(timer);
  };

  process.on("SIGINT", () => {
    stop();
    process.exit(0);
  });
  process.on("SIGTERM", () => {
    stop();
    process.exit(0);
  });
};

(watchMode ? watchAndGenerate() : generate()).catch((err) => {
  // eslint-disable-next-line no-console
  console.error(err);
  process.exitCode = 1;
});
